// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package openai

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/tonkean/pulumi-openai/sdk/go/openai/internal"
)

// Assistant resource
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/tonkean/pulumi-openai/sdk/go/openai"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := openai.NewAssistant(ctx, "test", &openai.AssistantArgs{
//				Description:  pulumi.String("tf-test-sample"),
//				Instructions: pulumi.String("You are a personal math tutor. When asked a question, write and run Python code to answer the question."),
//				Model:        pulumi.String("gpt-4"),
//				Tools: openai.AssistantToolArray{
//					&openai.AssistantToolArgs{
//						Type: pulumi.String("code_interpreter"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type Assistant struct {
	pulumi.CustomResourceState

	// The Unix timestamp (in seconds) for when the assistant was created.
	CreatedAt pulumi.IntOutput `pulumi:"createdAt"`
	// The description of the assistant. The maximum length is 512 characters.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The system instructions that the assistant uses. The maximum length is 32768 characters.
	Instructions pulumi.StringPtrOutput `pulumi:"instructions"`
	// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
	Metadata pulumi.StringMapOutput `pulumi:"metadata"`
	// ID of the model to use. You can use the List models API to see all of your available models.
	Model pulumi.StringOutput `pulumi:"model"`
	// The name of the assistant. The maximum length is 256 characters.
	Name pulumi.StringOutput `pulumi:"name"`
	// The object type, which is always assistant.
	Object pulumi.StringOutput `pulumi:"object"`
	// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
	Temperature pulumi.Float64PtrOutput `pulumi:"temperature"`
	// A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the code*interpreter tool requires a list of file IDs, while the file*search tool requires a list of vector store IDs.
	ToolResources AssistantToolResourcesPtrOutput `pulumi:"toolResources"`
	// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types code_interpreter, retrieval, or function.
	Tools AssistantToolArrayOutput `pulumi:"tools"`
	// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with topP probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
	TopP pulumi.Float64PtrOutput `pulumi:"topP"`
}

// NewAssistant registers a new resource with the given unique name, arguments, and options.
func NewAssistant(ctx *pulumi.Context,
	name string, args *AssistantArgs, opts ...pulumi.ResourceOption) (*Assistant, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Model == nil {
		return nil, errors.New("invalid value for required argument 'Model'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Assistant
	err := ctx.RegisterResource("openai:index/assistant:Assistant", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAssistant gets an existing Assistant resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAssistant(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AssistantState, opts ...pulumi.ResourceOption) (*Assistant, error) {
	var resource Assistant
	err := ctx.ReadResource("openai:index/assistant:Assistant", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Assistant resources.
type assistantState struct {
	// The Unix timestamp (in seconds) for when the assistant was created.
	CreatedAt *int `pulumi:"createdAt"`
	// The description of the assistant. The maximum length is 512 characters.
	Description *string `pulumi:"description"`
	// The system instructions that the assistant uses. The maximum length is 32768 characters.
	Instructions *string `pulumi:"instructions"`
	// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
	Metadata map[string]string `pulumi:"metadata"`
	// ID of the model to use. You can use the List models API to see all of your available models.
	Model *string `pulumi:"model"`
	// The name of the assistant. The maximum length is 256 characters.
	Name *string `pulumi:"name"`
	// The object type, which is always assistant.
	Object *string `pulumi:"object"`
	// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
	Temperature *float64 `pulumi:"temperature"`
	// A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the code*interpreter tool requires a list of file IDs, while the file*search tool requires a list of vector store IDs.
	ToolResources *AssistantToolResources `pulumi:"toolResources"`
	// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types code_interpreter, retrieval, or function.
	Tools []AssistantTool `pulumi:"tools"`
	// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with topP probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
	TopP *float64 `pulumi:"topP"`
}

type AssistantState struct {
	// The Unix timestamp (in seconds) for when the assistant was created.
	CreatedAt pulumi.IntPtrInput
	// The description of the assistant. The maximum length is 512 characters.
	Description pulumi.StringPtrInput
	// The system instructions that the assistant uses. The maximum length is 32768 characters.
	Instructions pulumi.StringPtrInput
	// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
	Metadata pulumi.StringMapInput
	// ID of the model to use. You can use the List models API to see all of your available models.
	Model pulumi.StringPtrInput
	// The name of the assistant. The maximum length is 256 characters.
	Name pulumi.StringPtrInput
	// The object type, which is always assistant.
	Object pulumi.StringPtrInput
	// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
	Temperature pulumi.Float64PtrInput
	// A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the code*interpreter tool requires a list of file IDs, while the file*search tool requires a list of vector store IDs.
	ToolResources AssistantToolResourcesPtrInput
	// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types code_interpreter, retrieval, or function.
	Tools AssistantToolArrayInput
	// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with topP probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
	TopP pulumi.Float64PtrInput
}

func (AssistantState) ElementType() reflect.Type {
	return reflect.TypeOf((*assistantState)(nil)).Elem()
}

type assistantArgs struct {
	// The description of the assistant. The maximum length is 512 characters.
	Description *string `pulumi:"description"`
	// The system instructions that the assistant uses. The maximum length is 32768 characters.
	Instructions *string `pulumi:"instructions"`
	// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
	Metadata map[string]string `pulumi:"metadata"`
	// ID of the model to use. You can use the List models API to see all of your available models.
	Model string `pulumi:"model"`
	// The name of the assistant. The maximum length is 256 characters.
	Name *string `pulumi:"name"`
	// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
	Temperature *float64 `pulumi:"temperature"`
	// A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the code*interpreter tool requires a list of file IDs, while the file*search tool requires a list of vector store IDs.
	ToolResources *AssistantToolResources `pulumi:"toolResources"`
	// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types code_interpreter, retrieval, or function.
	Tools []AssistantTool `pulumi:"tools"`
	// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with topP probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
	TopP *float64 `pulumi:"topP"`
}

// The set of arguments for constructing a Assistant resource.
type AssistantArgs struct {
	// The description of the assistant. The maximum length is 512 characters.
	Description pulumi.StringPtrInput
	// The system instructions that the assistant uses. The maximum length is 32768 characters.
	Instructions pulumi.StringPtrInput
	// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
	Metadata pulumi.StringMapInput
	// ID of the model to use. You can use the List models API to see all of your available models.
	Model pulumi.StringInput
	// The name of the assistant. The maximum length is 256 characters.
	Name pulumi.StringPtrInput
	// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
	Temperature pulumi.Float64PtrInput
	// A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the code*interpreter tool requires a list of file IDs, while the file*search tool requires a list of vector store IDs.
	ToolResources AssistantToolResourcesPtrInput
	// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types code_interpreter, retrieval, or function.
	Tools AssistantToolArrayInput
	// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with topP probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
	TopP pulumi.Float64PtrInput
}

func (AssistantArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*assistantArgs)(nil)).Elem()
}

type AssistantInput interface {
	pulumi.Input

	ToAssistantOutput() AssistantOutput
	ToAssistantOutputWithContext(ctx context.Context) AssistantOutput
}

func (*Assistant) ElementType() reflect.Type {
	return reflect.TypeOf((**Assistant)(nil)).Elem()
}

func (i *Assistant) ToAssistantOutput() AssistantOutput {
	return i.ToAssistantOutputWithContext(context.Background())
}

func (i *Assistant) ToAssistantOutputWithContext(ctx context.Context) AssistantOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AssistantOutput)
}

// AssistantArrayInput is an input type that accepts AssistantArray and AssistantArrayOutput values.
// You can construct a concrete instance of `AssistantArrayInput` via:
//
//	AssistantArray{ AssistantArgs{...} }
type AssistantArrayInput interface {
	pulumi.Input

	ToAssistantArrayOutput() AssistantArrayOutput
	ToAssistantArrayOutputWithContext(context.Context) AssistantArrayOutput
}

type AssistantArray []AssistantInput

func (AssistantArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Assistant)(nil)).Elem()
}

func (i AssistantArray) ToAssistantArrayOutput() AssistantArrayOutput {
	return i.ToAssistantArrayOutputWithContext(context.Background())
}

func (i AssistantArray) ToAssistantArrayOutputWithContext(ctx context.Context) AssistantArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AssistantArrayOutput)
}

// AssistantMapInput is an input type that accepts AssistantMap and AssistantMapOutput values.
// You can construct a concrete instance of `AssistantMapInput` via:
//
//	AssistantMap{ "key": AssistantArgs{...} }
type AssistantMapInput interface {
	pulumi.Input

	ToAssistantMapOutput() AssistantMapOutput
	ToAssistantMapOutputWithContext(context.Context) AssistantMapOutput
}

type AssistantMap map[string]AssistantInput

func (AssistantMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Assistant)(nil)).Elem()
}

func (i AssistantMap) ToAssistantMapOutput() AssistantMapOutput {
	return i.ToAssistantMapOutputWithContext(context.Background())
}

func (i AssistantMap) ToAssistantMapOutputWithContext(ctx context.Context) AssistantMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AssistantMapOutput)
}

type AssistantOutput struct{ *pulumi.OutputState }

func (AssistantOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Assistant)(nil)).Elem()
}

func (o AssistantOutput) ToAssistantOutput() AssistantOutput {
	return o
}

func (o AssistantOutput) ToAssistantOutputWithContext(ctx context.Context) AssistantOutput {
	return o
}

// The Unix timestamp (in seconds) for when the assistant was created.
func (o AssistantOutput) CreatedAt() pulumi.IntOutput {
	return o.ApplyT(func(v *Assistant) pulumi.IntOutput { return v.CreatedAt }).(pulumi.IntOutput)
}

// The description of the assistant. The maximum length is 512 characters.
func (o AssistantOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Assistant) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The system instructions that the assistant uses. The maximum length is 32768 characters.
func (o AssistantOutput) Instructions() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Assistant) pulumi.StringPtrOutput { return v.Instructions }).(pulumi.StringPtrOutput)
}

// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.
func (o AssistantOutput) Metadata() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Assistant) pulumi.StringMapOutput { return v.Metadata }).(pulumi.StringMapOutput)
}

// ID of the model to use. You can use the List models API to see all of your available models.
func (o AssistantOutput) Model() pulumi.StringOutput {
	return o.ApplyT(func(v *Assistant) pulumi.StringOutput { return v.Model }).(pulumi.StringOutput)
}

// The name of the assistant. The maximum length is 256 characters.
func (o AssistantOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Assistant) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The object type, which is always assistant.
func (o AssistantOutput) Object() pulumi.StringOutput {
	return o.ApplyT(func(v *Assistant) pulumi.StringOutput { return v.Object }).(pulumi.StringOutput)
}

// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
func (o AssistantOutput) Temperature() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Assistant) pulumi.Float64PtrOutput { return v.Temperature }).(pulumi.Float64PtrOutput)
}

// A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the code*interpreter tool requires a list of file IDs, while the file*search tool requires a list of vector store IDs.
func (o AssistantOutput) ToolResources() AssistantToolResourcesPtrOutput {
	return o.ApplyT(func(v *Assistant) AssistantToolResourcesPtrOutput { return v.ToolResources }).(AssistantToolResourcesPtrOutput)
}

// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types code_interpreter, retrieval, or function.
func (o AssistantOutput) Tools() AssistantToolArrayOutput {
	return o.ApplyT(func(v *Assistant) AssistantToolArrayOutput { return v.Tools }).(AssistantToolArrayOutput)
}

// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with topP probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
func (o AssistantOutput) TopP() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Assistant) pulumi.Float64PtrOutput { return v.TopP }).(pulumi.Float64PtrOutput)
}

type AssistantArrayOutput struct{ *pulumi.OutputState }

func (AssistantArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Assistant)(nil)).Elem()
}

func (o AssistantArrayOutput) ToAssistantArrayOutput() AssistantArrayOutput {
	return o
}

func (o AssistantArrayOutput) ToAssistantArrayOutputWithContext(ctx context.Context) AssistantArrayOutput {
	return o
}

func (o AssistantArrayOutput) Index(i pulumi.IntInput) AssistantOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Assistant {
		return vs[0].([]*Assistant)[vs[1].(int)]
	}).(AssistantOutput)
}

type AssistantMapOutput struct{ *pulumi.OutputState }

func (AssistantMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Assistant)(nil)).Elem()
}

func (o AssistantMapOutput) ToAssistantMapOutput() AssistantMapOutput {
	return o
}

func (o AssistantMapOutput) ToAssistantMapOutputWithContext(ctx context.Context) AssistantMapOutput {
	return o
}

func (o AssistantMapOutput) MapIndex(k pulumi.StringInput) AssistantOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Assistant {
		return vs[0].(map[string]*Assistant)[vs[1].(string)]
	}).(AssistantOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AssistantInput)(nil)).Elem(), &Assistant{})
	pulumi.RegisterInputType(reflect.TypeOf((*AssistantArrayInput)(nil)).Elem(), AssistantArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AssistantMapInput)(nil)).Elem(), AssistantMap{})
	pulumi.RegisterOutputType(AssistantOutput{})
	pulumi.RegisterOutputType(AssistantArrayOutput{})
	pulumi.RegisterOutputType(AssistantMapOutput{})
}
